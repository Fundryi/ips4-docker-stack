#!/bin/bash
# Initialize SSL certificates with Let's Encrypt
# Usage: ./scripts/init-ssl.sh [domain] [email]
# If domain and email are not provided, they will be read from .env file
# Uses DNS challenge (Cloudflare) if CLOUDFLARE_API_TOKEN is set, otherwise HTTP challenge

set -e

# Try to read from .env file if it exists
if [ -f .env ]; then
    # Source variables from .env file
    export $(grep -v '^#' .env | grep -E '^(DOMAIN|CERTBOT_EMAIL|CLOUDFLARE_API_TOKEN)=' | xargs 2>/dev/null) || true
fi

# Use provided arguments or fall back to .env values
DOMAIN=${1:-$DOMAIN}
EMAIL=${2:-$CERTBOT_EMAIL}

if [ -z "$DOMAIN" ] || [ -z "$EMAIL" ]; then
    echo "Error: Domain and email are required!"
    echo ""
    echo "Usage: $0 [domain] [email]"
    echo "Example: $0 example.com admin@example.com"
    echo ""
    echo "Alternatively, set DOMAIN and CERTBOT_EMAIL in your .env file:"
    echo "  DOMAIN=example.com"
    echo "  CERTBOT_EMAIL=admin@example.com"
    exit 1
fi

echo "==> Using domain: $DOMAIN"
echo "==> Using email: $EMAIL"

# Determine challenge type
if [ -n "$CLOUDFLARE_API_TOKEN" ]; then
    CHALLENGE_TYPE="dns"
    echo "==> Using DNS challenge (Cloudflare)"
else
    CHALLENGE_TYPE="http"
    echo "==> Using HTTP challenge (port 80 must be accessible)"
fi
echo ""

# Check if certificate already exists and is valid for at least 30 days
CERT_PATH="data/ssl/live/$DOMAIN/fullchain.pem"
if [ -f "$CERT_PATH" ]; then
    echo "==> Checking existing certificate..."
    # Check if certificate expires in more than 30 days
    if openssl x509 -checkend 2592000 -noout -in "$CERT_PATH" 2>/dev/null; then
        EXPIRY_DATE=$(openssl x509 -enddate -noout -in "$CERT_PATH" 2>/dev/null | cut -d= -f2)
        echo "    Certificate is still valid (expires: $EXPIRY_DATE)"
        echo "    Skipping certificate request to avoid Let's Encrypt rate limits."
        echo ""

        # Still create symlinks and enable HTTPS in case they're missing
        echo "==> Verifying certificate symlinks..."
        cd data/ssl
        ln -sf "live/$DOMAIN/fullchain.pem" fullchain.pem
        ln -sf "live/$DOMAIN/privkey.pem" privkey.pem
        cd ../..
        echo "    Symlinks verified"

        echo "==> Enabling HTTPS in .env..."
        if [ -f .env ]; then
            if grep -q "^COMPOSE_PROFILES=" .env; then
                sed -i 's/^COMPOSE_PROFILES=.*/COMPOSE_PROFILES=https/' .env
                echo "    Set COMPOSE_PROFILES=https"
            else
                echo "COMPOSE_PROFILES=https" >> .env
                echo "    Added COMPOSE_PROFILES=https"
            fi
        fi

        echo ""
        echo "==> SSL setup complete! (using existing certificate)"
        echo "    Start with: docker compose up -d"
        exit 0
    else
        echo "    Certificate expires within 30 days, will renew..."
    fi
fi

echo "==> Creating required directories..."
mkdir -p data/ssl data/certbot/www data/certbot/logs certbot

# Check for stale certbot state (accounts exist but no certificates)
# This can cause "No such authorization" errors
if [ -d "data/ssl/accounts" ] && [ ! -d "data/ssl/live" ]; then
    echo "==> Detected stale certbot state, cleaning up..."
    rm -rf data/ssl/accounts
    rm -rf data/ssl/renewal
    rm -rf data/ssl/renewal-hooks
    rm -f data/ssl/cloudflare.ini
    echo "    Cleanup complete."
fi

echo "==> Stopping any running containers to free ports..."
docker compose down 2>/dev/null || true

if [ "$CHALLENGE_TYPE" = "dns" ]; then
    # DNS Challenge (Cloudflare)
    echo "==> Creating Cloudflare credentials file..."
    cat > certbot/cloudflare.ini << EOF
# Cloudflare API credentials - auto-generated by init-ssl.sh
dns_cloudflare_api_token = $CLOUDFLARE_API_TOKEN
EOF
    chmod 600 certbot/cloudflare.ini

    echo "==> Requesting certificate via DNS challenge..."
    docker run --rm \
        -v "$(pwd)/data/ssl:/etc/letsencrypt" \
        -v "$(pwd)/data/certbot/logs:/var/log/letsencrypt" \
        -v "$(pwd)/certbot/cloudflare.ini:/etc/letsencrypt/cloudflare.ini:ro" \
        certbot/dns-cloudflare:latest certonly \
        --dns-cloudflare \
        --dns-cloudflare-credentials /etc/letsencrypt/cloudflare.ini \
        --dns-cloudflare-propagation-seconds 30 \
        --email "$EMAIL" \
        --agree-tos \
        --no-eff-email \
        -d "$DOMAIN"
else
    # HTTP Challenge
    echo "==> Starting nginx for ACME challenge..."
    docker compose --profile http up -d nginx

    echo "==> Waiting for nginx to be ready..."
    sleep 5

    echo "==> Requesting certificate via HTTP challenge..."
    docker compose --profile http run --rm certbot certonly \
        --webroot \
        --webroot-path=/var/www/certbot \
        --email "$EMAIL" \
        --agree-tos \
        --no-eff-email \
        -d "$DOMAIN"

    echo "==> Stopping nginx..."
    docker compose --profile http down
fi

echo "==> Creating certificate symlinks..."
# Create symlinks relative to the data/ssl directory
cd data/ssl
ln -sf "live/$DOMAIN/fullchain.pem" fullchain.pem
ln -sf "live/$DOMAIN/privkey.pem" privkey.pem
cd ../..

echo "==> Enabling HTTPS in .env..."
if [ -f .env ]; then
    if grep -q "^COMPOSE_PROFILES=" .env; then
        sed -i 's/^COMPOSE_PROFILES=.*/COMPOSE_PROFILES=https/' .env
        echo "    Set COMPOSE_PROFILES=https"
    else
        echo "COMPOSE_PROFILES=https" >> .env
        echo "    Added COMPOSE_PROFILES=https"
    fi
else
    echo "    Warning: .env file not found. Create it from .env.example and set COMPOSE_PROFILES=https"
fi

echo ""
echo "==> SSL setup complete!"
echo "    Start with: docker compose up -d"
